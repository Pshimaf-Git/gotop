
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gotop: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Pshimaf-Git/gotop/cmd/gotop/main.go (0.0%)</option>
				
				<option value="file1">github.com/Pshimaf-Git/gotop/internal/config/config.go (66.7%)</option>
				
				<option value="file2">github.com/Pshimaf-Git/gotop/internal/process/collector.go (80.0%)</option>
				
				<option value="file3">github.com/Pshimaf-Git/gotop/internal/process/model.go (88.9%)</option>
				
				<option value="file4">github.com/Pshimaf-Git/gotop/internal/ui/app.go (0.0%)</option>
				
				<option value="file5">github.com/Pshimaf-Git/gotop/internal/ui/table.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"
        "os/signal"
        "syscall"

        "github.com/Pshimaf-Git/gotop/internal/config"
        "github.com/Pshimaf-Git/gotop/internal/process"
        "github.com/Pshimaf-Git/gotop/internal/ui"
)

func main() <span class="cov0" title="0">{
        log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile)

        cfg, err := config.Load(config.FetchConfigPath())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("config parse failed: %s", err.Error())
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                sig := &lt;-sigChan
                fmt.Fprintf(os.Stderr, "Stoped by signal %s\n", sig.String())
                cancel()
        }</span>()

        <span class="cov0" title="0">app := ui.NewApp()

        processInfoChan := process.GetProcessInfoChan(ctx, cfg.RefreshInterval)

        err = app.Run(ctx, processInfoChan, cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("UI appication failed: %s", err.Error())
        }</span>

        <span class="cov0" title="0">log.Println("gotop finished")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "bufio"
        "errors"
        "fmt"
        "io"
        "os"
        "time"

        "github.com/spf13/pflag"
        "gopkg.in/yaml.v3"
)

type Config struct {
        RefreshInterval     time.Duration `yaml:"refresh_interval" env:"REFRESH_INTERVAL"`
        ColumnBordersColor  string        `yaml:"column_borders_color" env:"COLUMN_BORDERS_COLOR"`
        ShowColumnSeparator bool          `yaml:"show_column_separator" env:"SHOW_COLUMN_SEPARATOR"`
}

func Load(cfgPath string) (Config, error) <span class="cov8" title="1">{
        file, err := os.Open(cfgPath)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                        return Config{}, fmt.Errorf("file %s: not exist: %w", cfgPath, err)
                }</span>
                <span class="cov0" title="0">return Config{}, fmt.Errorf("open file&lt;%s&gt;: %w", cfgPath, err)</span>
        }

        <span class="cov8" title="1">defer file.Close()

        data, err := io.ReadAll(bufio.NewReader(file))

        var cfg Config
        if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov8" title="1">{
                return Config{}, fmt.Errorf("parse config file&lt;%s&gt;: %w", cfgPath, err)
        }</span>

        <span class="cov8" title="1">return cfg, nil</span>
}

const (
        CONFIG_PATH    = "CONFIG_PATH"
        defaultCfgPath = "configs/config.yaml"
)

func FetchConfigPath() string <span class="cov0" title="0">{
        var cfgPath string
        pflag.StringVarP(&amp;cfgPath, "config-path", "c", defaultCfgPath, "path to file with config")
        pflag.Parse()

        return cfgPath
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package process

import (
        "context"
        "time"

        "github.com/shirou/gopsutil/v3/process"
)

func GetProcessInfoChan(ctx context.Context, interval time.Duration) &lt;-chan ProcessInfo <span class="cov8" title="1">{
        info := make(chan ProcessInfo)

        go func() </span><span class="cov8" title="1">{
                defer close(info)

                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return</span>
                        default:<span class="cov8" title="1"></span>
                        }

                        <span class="cov8" title="1">processes, err := process.ProcessesWithContext(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                time.Sleep(interval)
                                continue</span>
                        }

                        <span class="cov8" title="1">for _, proc := range processes </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov8" title="1">
                                        return</span>

                                case info &lt;- FromProcess(ctx, proc):<span class="cov8" title="1"></span>
                                }
                        }

                        <span class="cov0" title="0">time.Sleep(interval)</span>
                }
        }()

        <span class="cov8" title="1">return info</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package process

import (
        "context"
        "fmt"
        "strings"

        "github.com/shirou/gopsutil/v3/process"
)

type ProcessInfo struct {
        PID        int32
        PPID       int32
        Name       string
        CPUPercent float64
        MemoryMB   uint64
        ComandLine string
        Username   string
        Status     string
}

const (
        UNKOWN_PPID = -1
        UNKOWN_NAME = "N/A"
)

const (
        STATUS_SEP = ", "
)

func FromProcess(ctx context.Context, process *process.Process) ProcessInfo <span class="cov8" title="1">{
        name, err := process.NameWithContext(ctx)
        if err != nil </span><span class="cov8" title="1">{
                name = UNKOWN_NAME
        }</span>

        <span class="cov8" title="1">cpuPercent, err := process.CPUPercentWithContext(ctx)
        if err != nil </span><span class="cov8" title="1">{
                cpuPercent = 0.0
        }</span>

        <span class="cov8" title="1">var rssMB uint64
        memInfo, err := process.MemoryInfoWithContext(ctx)
        if err == nil &amp;&amp; memInfo != nil </span><span class="cov0" title="0">{
                rssMB = toMB(memInfo.RSS)
        }</span>

        <span class="cov8" title="1">ppid, err := process.PpidWithContext(ctx)
        if err != nil </span><span class="cov8" title="1">{
                ppid = UNKOWN_PPID
        }</span>

        <span class="cov8" title="1">cmdLine, err := process.CmdlineWithContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                cmdLine = UNKOWN_NAME
        }</span>
        <span class="cov8" title="1">cmdLine = strings.TrimSpace(cmdLine)

        username, err := process.UsernameWithContext(ctx)
        if err != nil </span><span class="cov8" title="1">{
                username = UNKOWN_NAME
        }</span>

        <span class="cov8" title="1">statuses, err := process.StatusWithContext(ctx)
        if err != nil </span><span class="cov8" title="1">{
                statuses = []string{UNKOWN_NAME}
        }</span>
        <span class="cov8" title="1">status := strings.Join(statuses, STATUS_SEP)

        return ProcessInfo{
                PID:        process.Pid,
                PPID:       ppid,
                Name:       name,
                CPUPercent: cpuPercent,
                MemoryMB:   rssMB,
                ComandLine: cmdLine,
                Username:   username,
                Status:     status,
        }</span>
}

func (pi *ProcessInfo) String() string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "PID: %d, PPID: %d, Name %s, CPU: %.1f, Memory: %dMB, Cmd: %s, User: %s, Status: %s",
                pi.PID, pi.PPID, pi.Name, pi.CPUPercent, pi.MemoryMB, pi.ComandLine, pi.Username, pi.Status,
        )
}</span>

func toMB(rss uint64) uint64 <span class="cov0" title="0">{
        return rss / (1024 * 1024)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package ui

import (
        "context"
        "time"

        "github.com/Pshimaf-Git/gotop/internal/config"
        "github.com/Pshimaf-Git/gotop/internal/process"
        "github.com/gdamore/tcell/v2"
        "github.com/rivo/tview"
)

type App struct {
        app *tview.Application
}

func NewApp() App <span class="cov0" title="0">{
        return App{
                app: tview.NewApplication(),
        }
}</span>

func (a *App) Run(ctx context.Context, processInfo &lt;-chan process.ProcessInfo, cfg config.Config) error <span class="cov0" title="0">{
        processTable := NewProcessTable(cfg)

        a.app.SetRoot(processTable.GetTable(), true)

        a.app.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
                if event.Key() == tcell.KeyRune </span><span class="cov0" title="0">{
                        col := int(event.Rune() - '1')
                        if col &gt;= 0 &amp;&amp; col &lt; len(headers) </span><span class="cov0" title="0">{
                                processTable.SetSortColumn(col)
                        }</span>
                }
                <span class="cov0" title="0">return event</span>
        })

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                allProcesses := make(map[int32]process.ProcessInfo)
                updateTicket := time.NewTicker(1000 * time.Millisecond)

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>

                        case pInfo, ok := &lt;-processInfo:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">allProcesses[pInfo.PID] = pInfo</span>

                        case &lt;-updateTicket.C:<span class="cov0" title="0">
                                a.app.QueueUpdateDraw(func() </span><span class="cov0" title="0">{
                                        processTable.UpdateData(allProcesses)
                                }</span>)
                        }
                }
        }()

        <span class="cov0" title="0">return a.app.Run()</span>
}

func (a *App) Stop() <span class="cov0" title="0">{
        a.app.Stop()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package ui

import (
        "fmt"
        "sort"
        "strconv"
        "strings"

        "github.com/Pshimaf-Git/gotop/internal/config"
        "github.com/Pshimaf-Git/gotop/internal/process"
        "github.com/gdamore/tcell/v2"
        "github.com/rivo/tview"
)

var colors = tcell.ColorNames

type ProcessTable struct {
        *tview.Table
        sortByColomn int
        sortOrder    string
}

const (
        DESC = "desc"
        ASC  = "asc"
)

const (
        arrowUp   = "▲"
        arrowDown = "▼"
)

var headers = []string{
        "PID(1)", "PPID(2)", "Name(3)", "CPU (%)(4)", "Memory (MB)(5)", "User(6)", "Comand line(7)", "Status(8)",
}

const (
        pid = iota
        ppid
        name
        cpu
        memory
        user
        comandLine
        status
)

func NewProcessTable(cfg config.Config) ProcessTable <span class="cov0" title="0">{
        table := tview.NewTable().
                SetBorders(true).
                SetSelectable(true, false).SetFixed(1, 0)

        if cfg.ShowColumnSeparator </span><span class="cov0" title="0">{
                table.SetSeparator(tview.Borders.Vertical)
        }</span>

        <span class="cov0" title="0">if color, ok := colors[cfg.ColumnBordersColor]; ok </span><span class="cov0" title="0">{
                table.SetBordersColor(color)
        }</span> else<span class="cov0" title="0"> {
                table.SetBordersColor(tcell.ColorWhite)
        }</span>

        <span class="cov0" title="0">pt := ProcessTable{
                Table:        table,
                sortByColomn: cpu,
                sortOrder:    DESC,
        }

        pt.setupHeaders()

        return pt</span>
}

func (pt *ProcessTable) SetSortColumn(col int) <span class="cov0" title="0">{
        if pt.sortByColomn == col </span><span class="cov0" title="0">{
                pt.SwapOrder()
        }</span> else<span class="cov0" title="0"> {
                pt.sortByColomn = col
                pt.sortOrder = DESC
        }</span>
}

func (pt *ProcessTable) SwapOrder() <span class="cov0" title="0">{
        if pt.sortOrder == ASC </span><span class="cov0" title="0">{
                pt.sortOrder = DESC
        }</span> else<span class="cov0" title="0"> {
                pt.sortOrder = ASC
        }</span>
}

func (pt *ProcessTable) GetTable() *tview.Table <span class="cov0" title="0">{
        return pt.Table
}</span>

func (pt *ProcessTable) setupHeaders() <span class="cov0" title="0">{
        for col, header := range headers </span><span class="cov0" title="0">{
                cell := tview.NewTableCell(header).
                        SetAlign(tview.AlignCenter).SetTextColor(tcell.ColorYellow).SetSelectable(false)

                if col == pt.sortByColomn </span><span class="cov0" title="0">{
                        arrow := addSpace(arrowUp)
                        if pt.sortOrder == DESC </span><span class="cov0" title="0">{
                                arrow = addSpace(arrowDown)
                        }</span>

                        <span class="cov0" title="0">cell.SetText(header + arrow)</span>
                }

                <span class="cov0" title="0">pt.Table.SetCell(0, col, cell)</span>
        }

}

func (pt *ProcessTable) UpdateData(processes map[int32]process.ProcessInfo) <span class="cov0" title="0">{
        processesList := make([]process.ProcessInfo, 0, len(processes))

        for _, pInfo := range processes </span><span class="cov0" title="0">{
                processesList = append(processesList, pInfo)
        }</span>

        <span class="cov0" title="0">sort.Slice(processesList, func(i, j int) bool </span><span class="cov0" title="0">{
                a := processesList[i]
                b := processesList[j]

                var less bool
                switch pt.sortByColomn </span>{
                case pid:<span class="cov0" title="0">
                        less = a.PID &lt; b.PID</span>
                case ppid:<span class="cov0" title="0">
                        less = a.PPID &lt; b.PPID</span>
                case name:<span class="cov0" title="0">
                        less = strings.ToLower(a.Name) &lt; strings.ToLower(b.Name)</span>
                case cpu:<span class="cov0" title="0">
                        less = a.CPUPercent &lt; b.CPUPercent</span>
                case memory:<span class="cov0" title="0">
                        less = a.MemoryMB &lt; b.MemoryMB</span>
                case user:<span class="cov0" title="0">
                        less = strings.ToLower(a.Username) &lt; strings.ToLower(b.Username)</span>
                case comandLine:<span class="cov0" title="0">
                        less = strings.ToLower(a.ComandLine) &lt; strings.ToLower(b.ComandLine)</span>
                case status:<span class="cov0" title="0">
                        less = strings.ToLower(a.Status) &lt; strings.ToLower(b.Status)</span>
                default:<span class="cov0" title="0">
                        less = a.PID &lt; b.PID</span>
                }

                <span class="cov0" title="0">if pt.sortOrder == DESC </span><span class="cov0" title="0">{
                        return !less
                }</span>

                <span class="cov0" title="0">return less</span>
        })

        <span class="cov0" title="0">for i := pt.Table.GetRowCount() - 1; i &gt; 0; i-- </span><span class="cov0" title="0">{
                pt.Table.RemoveRow(i)
        }</span>

        <span class="cov0" title="0">row := 1
        for _, pInfo := range processesList </span><span class="cov0" title="0">{
                pt.SetCellPID(row, pInfo).
                        SetCellPPID(row, pInfo).
                        SetCellName(row, pInfo).
                        SetCellCPUPercent(row, pInfo).
                        SetCellMemoryMB(row, pInfo).
                        SetCellUsername(row, pInfo).
                        SetCellComandLine(row, pInfo).
                        SetCellStatus(row, pInfo)

                row++
        }</span>

        <span class="cov0" title="0">pt.setupHeaders()</span>
}

func (pt *ProcessTable) SetCellPID(row int, pInfo process.ProcessInfo) *ProcessTable <span class="cov0" title="0">{
        pt.Table.SetCell(row, pid, tview.NewTableCell(strconv.Itoa(int(pInfo.PID))).SetAlign(tview.AlignCenter))
        return pt
}</span>

func (pt *ProcessTable) SetCellPPID(row int, pInfo process.ProcessInfo) *ProcessTable <span class="cov0" title="0">{
        pt.Table.SetCell(row, ppid, tview.NewTableCell(strconv.Itoa(int(pInfo.PPID))).SetAlign(tview.AlignCenter))
        return pt
}</span>

func (pt *ProcessTable) SetCellName(row int, pInfo process.ProcessInfo) *ProcessTable <span class="cov0" title="0">{
        pt.Table.SetCell(row, name, tview.NewTableCell(pInfo.Name).SetAlign(tview.AlignCenter))
        return pt
}</span>

func (pt *ProcessTable) SetCellStatus(row int, pInfo process.ProcessInfo) *ProcessTable <span class="cov0" title="0">{
        pt.Table.SetCell(row, status, tview.NewTableCell(pInfo.Status).SetAlign(tview.AlignCenter))
        return pt
}</span>

func (pt *ProcessTable) SetCellUsername(row int, pInfo process.ProcessInfo) *ProcessTable <span class="cov0" title="0">{
        pt.Table.SetCell(row, user, tview.NewTableCell(pInfo.Username).SetAlign(tview.AlignCenter))
        return pt
}</span>

func (pt *ProcessTable) SetCellComandLine(row int, pInfo process.ProcessInfo) *ProcessTable <span class="cov0" title="0">{
        pt.Table.SetCell(row, comandLine, tview.NewTableCell(pInfo.ComandLine).SetAlign(tview.AlignCenter))
        return pt

}</span>

func (pt *ProcessTable) SetCellCPUPercent(row int, pInfo process.ProcessInfo) *ProcessTable <span class="cov0" title="0">{
        pt.Table.SetCell(row, cpu, tview.NewTableCell(fmt.Sprintf("%.1f", pInfo.CPUPercent)).SetAlign(tview.AlignCenter))
        return pt
}</span>

func (pt *ProcessTable) SetCellMemoryMB(row int, pInfo process.ProcessInfo) *ProcessTable <span class="cov0" title="0">{
        pt.Table.SetCell(row, memory, tview.NewTableCell(fmt.Sprintf("%d", pInfo.MemoryMB)).SetAlign(tview.AlignCenter))
        return pt
}</span>

func addSpace(s string) string <span class="cov0" title="0">{
        return " " + s
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
